import { mkdirSync, writeFileSync } from 'node:fs';
import { dirname, join } from 'node:path';
import { z } from 'zod';
import { zodToTs, printNode } from 'zod-to-ts';

export type RegisteredSchema<TSchema extends z.ZodTypeAny = z.ZodTypeAny> = {
  name: string;
  schema: TSchema;
};

const registry = new Map<string, z.ZodTypeAny>();

export function defineSchema<TSchema extends z.ZodTypeAny>(name: string, schema: TSchema): TSchema {
  if (!name || name.trim().length === 0) {
    throw new Error('schema_name_required');
  }
  if (registry.has(name)) {
    throw new Error(`schema_already_registered:${name}`);
  }
  registry.set(name, schema);
  return schema;
}

export function getSchema<TSchema extends z.ZodTypeAny = z.ZodTypeAny>(name: string): TSchema {
  const schema = registry.get(name);
  if (!schema) {
    throw new Error(`schema_not_found:${name}`);
  }
  return schema as TSchema;
}

export function listSchemas(): RegisteredSchema[] {
  return Array.from(registry.entries()).map(([name, schema]) => ({ name, schema }));
}

export interface GenerateSchemaTypesOptions {
  outputPath?: string;
  banner?: string;
}

export function generateSchemaTypes({
  outputPath = join(process.cwd(), 'src/core/schema/registry-types.d.ts'),
  banner = '// AUTO-GENERATED BY schema:generate. DO NOT EDIT.\n',
}: GenerateSchemaTypesOptions = {}): void {
  const chunks: string[] = [banner, "import type { z } from 'zod';\n\n"];

  for (const { name, schema } of listSchemas()) {
    const identifier = name.replace(/[^A-Za-z0-9_]/g, '_');
    const { node } = zodToTs(schema, identifier);
    chunks.push(`export type ${identifier}Schema = ${printNode(node)};\n`);
    chunks.push(`export type ${identifier} = z.infer<typeof ${identifier}Schema>;\n\n`);
  }

  const filePath = outputPath;
  const directory = dirname(filePath);
  mkdirSync(directory, { recursive: true });
  writeFileSync(filePath, chunks.join(''));
}

export { z };
