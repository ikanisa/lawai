create table if not exists public.agent_policy_versions (
  id uuid primary key default gen_random_uuid(),
  name text,
  notes text,
  activated_at timestamptz,
  created_at timestamptz not null default now()
);

-- Add new columns if they don't exist (migration from old schema)
do $$
begin
  if not exists (select 1 from information_schema.columns where table_name = 'agent_policy_versions' and column_name = 'org_id') then
    alter table public.agent_policy_versions add column org_id uuid references public.organizations(id) on delete cascade;
  end if;
  if not exists (select 1 from information_schema.columns where table_name = 'agent_policy_versions' and column_name = 'version_number') then
    alter table public.agent_policy_versions add column version_number bigint generated by default as identity;
  end if;
  if not exists (select 1 from information_schema.columns where table_name = 'agent_policy_versions' and column_name = 'status') then
    alter table public.agent_policy_versions add column status text not null default 'draft';
  end if;
  if not exists (select 1 from information_schema.columns where table_name = 'agent_policy_versions' and column_name = 'change_set') then
    alter table public.agent_policy_versions add column change_set jsonb not null default '[]'::jsonb;
  end if;
  if not exists (select 1 from information_schema.columns where table_name = 'agent_policy_versions' and column_name = 'created_by') then
    alter table public.agent_policy_versions add column created_by uuid;
  end if;
  if not exists (select 1 from information_schema.columns where table_name = 'agent_policy_versions' and column_name = 'approved_by') then
    alter table public.agent_policy_versions add column approved_by uuid;
  end if;
  if not exists (select 1 from information_schema.columns where table_name = 'agent_policy_versions' and column_name = 'approved_at') then
    alter table public.agent_policy_versions add column approved_at timestamptz;
  end if;
end $$;

create index if not exists idx_agent_policy_versions_org on public.agent_policy_versions(org_id, version_number desc) where org_id is not null;

alter table public.agent_policy_versions enable row level security;

drop policy if exists "agent_policy_versions_policy" on public.agent_policy_versions;

create policy "agent_policy_versions_policy" on public.agent_policy_versions
  for all
  using (public.is_org_member(org_id))
  with check (public.is_org_member(org_id));

create table if not exists public.agent_learning_jobs (
  id uuid primary key default gen_random_uuid(),
  org_id uuid not null references public.organizations(id) on delete cascade,
  job_type text not null,
  status text not null default 'READY',
  payload jsonb not null default '{}'::jsonb,
  policy_version_id uuid references public.agent_policy_versions(id) on delete set null,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create index if not exists idx_agent_learning_jobs_org on public.agent_learning_jobs(org_id, status);

alter table public.agent_learning_jobs enable row level security;

drop policy if exists "agent_learning_jobs_policy" on public.agent_learning_jobs;

create policy "agent_learning_jobs_policy" on public.agent_learning_jobs
  for all
  using (public.is_org_member(org_id))
  with check (public.is_org_member(org_id));

create or replace function public.touch_agent_learning_jobs()
returns trigger
language plpgsql
as $$
begin
  new.updated_at := now();
  return new;
end;
$$;

drop trigger if exists trg_touch_agent_learning_jobs on public.agent_learning_jobs;

create trigger trg_touch_agent_learning_jobs
  before update on public.agent_learning_jobs
  for each row
  execute function public.touch_agent_learning_jobs();
